#!/usr/bin/env python3
# encoding: utf-8

import argparse
import datetime
import os
import re
import shutil
import subprocess


class Configuration:
    DEBUG = False

    NUMBER_OF_LINE_ON_LIST = 3
    GRAPHICAL_EDITOR = "xdg-open"
    CLI_EDITOR = "vim"

    NOTE_REPO_NAME = "repository"
    NOTE_REPO_PATH = os.path.join(os.path.dirname(os.path.realpath(__file__)), NOTE_REPO_NAME)

    NOTE_NAME_PREFIX = "note_"
    NOTE_EXTENSION = "md"
    ENCRYPTED_NOTE_EXTENSION = ".gpg"

    TEMPLATE_NAME = ".template.md"
    TEMPLATE_PATH = os.path.join(NOTE_REPO_PATH, TEMPLATE_NAME)

    PGRM_DESC = '''
Small utility to save notes.
Notes are saved in: ''' + NOTE_REPO_PATH


class Colors:
    PURPLE = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    UNDERLINE = '\033[4m'


class Logger:

    @staticmethod
    def header(line=""):
        Logger.printColor(line, Colors.UNDERLINE)

    @staticmethod
    def success(line=""):
        Logger.printColor(line, Colors.GREEN)

    @staticmethod
    def info(line=""):
        Logger.printColor(line)

    @staticmethod
    def warning(line=""):
        Logger.printColor(line, Colors.YELLOW)

    @staticmethod
    def error(line=""):
        Logger.printColor(line, Colors.RED)

    @staticmethod
    def printColor(line="", color=Colors.ENDC):
        print(color + str(line) + Colors.ENDC)

    @staticmethod
    def debug(data):
        if Configuration.DEBUG:
            Logger.printColor('Debug: ', Colors.YELLOW)
            print(data)


def isLineEmpty(line):
    return re.search("[a-z0-9]+", line, re.IGNORECASE) is None


def displayNote(notePath, lineMax=None, regex=None):
    # FIXME: avoid list all notes for just index
    Logger.printColor("@ Number: " + str(listNotePaths().index(notePath)), Colors.GREEN)
    Logger.info("@ Name: " + notePath.split(os.sep)[-1])
    Logger.info("@ Path: " + notePath)
    Logger.info("")

    displayedLines = 0
    titlePrinted = False
    for line in getLinesFromNote(notePath):

        # avoid printing first empty lines
        if titlePrinted is False and isLineEmpty(line):
            continue
        else:
            titlePrinted = True

        if displayedLines == 0:
            Logger.printColor(line[0:-1], Colors.BLUE + Colors.UNDERLINE)
            Logger.info()
            displayedLines += 1

        # otherwise print normally, but without end of line
        else:
            if regex is None:
                Logger.info(line[0:-1])
                displayedLines += 1
            # if regex is provided, show only matching lines
            else:
                match = re.search(regex, line, re.IGNORECASE)
                if match is not None:
                    line = re.sub(regex, Colors.YELLOW + match.group(1) + Colors.ENDC, line, re.IGNORECASE)
                    Logger.info(line[0:-1])
                    displayedLines += 1

        if lineMax is not None and displayedLines > lineMax:
            break

    if displayedLines == 0:
        Logger.warning("** Note is empty **")

    Logger.info("")


def displayNoteCompact(notePath):
    Logger.printColor("@ Number: " + str(listNotePaths().index(notePath)), Colors.GREEN)
    Logger.info("@ Name: " + notePath.split(os.sep)[-1])

    for line in getLinesFromNote(notePath):
        if isLineEmpty(line):
            continue
        Logger.printColor(line[0:-1], Colors.BLUE)
        break

    Logger.info()


def resolveNoteName(data, includeEncrypted=False):
    """
    Try to resolve a note name regardless it is a note name, partial name or number.
    Return None if nothing is found
    """
    # arg is a full path
    if os.path.isfile(data) is True:
        return data

    # arg is a note number
    if re.search("^[0-9]*$", data):
        notes = listNotePaths(includeEncrypted)
        if int(data) < len(notes):
            return notes[int(data)]

    # arg is a relative path or a partial name
    if len(data.split(os.sep)) < 2:

        # relative path: return absolute path
        notePath = os.path.join(Configuration.NOTE_REPO_PATH, data)
        if os.path.isfile(notePath):
            return notePath

        # partial name: search
        for path in listNotePaths(includeEncrypted):
            if re.search(data, path, re.IGNORECASE) is not None:
                return path

    return None


def getLinesFromNote(notePath):
    with open(notePath, "r") as file:
        return file.readlines()


def listNotePaths(includeEncrypted=False):
    """
    Return an ordered list of note paths
    """

    # list files from directory
    output = []
    dirList = os.listdir(Configuration.NOTE_REPO_PATH)

    # remove uneeded files
    for fname in dirList:
        if fname != "." and fname != ".." and fname != Configuration.TEMPLATE_NAME:
            if (includeEncrypted and fname.endswith(Configuration.ENCRYPTED_NOTE_EXTENSION)) \
                    or fname.endswith(Configuration.NOTE_EXTENSION):
                output.append(os.path.join(Configuration.NOTE_REPO_PATH, fname))

    output.sort()

    # return result
    return output


def editNote(notePath, useGraphicalEditor=False):
    """
    Edit a note, with graphical or non graphical editor
    """
    # choose editor
    editor = Configuration.GRAPHICAL_EDITOR if useGraphicalEditor == True else Configuration.CLI_EDITOR

    # call editor
    subprocess.call(editor + " " + notePath, shell=True)


def createNewNote(suffix=None):
    today = datetime.datetime.now()
    newNoteName = Configuration.NOTE_NAME_PREFIX + today.strftime('%Y-%m-%d_%H-%M-%S')
    if suffix != None:
        newNoteName += "_" + suffix
    newNoteName += "." + Configuration.NOTE_EXTENSION

    newNotePath = os.path.join(Configuration.NOTE_REPO_PATH, newNoteName)

    # create file from template
    shutil.copy(Configuration.TEMPLATE_PATH, newNotePath)

    # return full path
    return newNotePath


def checkNoteRepository():
    """
    Check if repository and templates exist, or try to create them
    """

    if os.path.isdir(Configuration.NOTE_REPO_PATH) == False:
        os.makedirs(Configuration.NOTE_REPO_PATH)
        Logger.info("Note repository was created here: " + Configuration.NOTE_REPO_PATH)

    # create note template
    if os.path.isfile(Configuration.TEMPLATE_PATH) == False:
        with open(Configuration.TEMPLATE_PATH, 'a') as file:
            file.close()


def encryptGpg(noteFullPath):
    encryptedNoteName = clearToEncryptedNoteName(noteFullPath)
    encryptNoteCommand = "gpg --yes --armor --output " + encryptedNoteName + " --symmetric " + noteFullPath + " && sync"

    returnCode = subprocess.call(encryptNoteCommand, shell=True)
    returnCode += subprocess.call("shred -u " + noteFullPath + " && sync", shell=True)

    if returnCode != 0:
        raise Exception("/!\ Unable to encrypt note: " + noteFullPath)


def decryptGpg(noteFullPath):
    clearNoteName = encryptedToClearNoteName(noteFullPath)
    print(noteFullPath)
    print(clearNoteName)
    decryptCommand = "gpg --yes --decrypt --output " + clearNoteName + " " + noteFullPath + " && sync"
    returnCode = subprocess.call(decryptCommand, shell=True)

    if returnCode != 0:
        raise Exception("/!\ Unable to decrypt note: " + noteFullPath)


def clearToEncryptedNoteName(noteName):
    return noteName + Configuration.ENCRYPTED_NOTE_EXTENSION


def encryptedToClearNoteName(noteName):
    return noteName[:-len(Configuration.ENCRYPTED_NOTE_EXTENSION)]


def buildSearchRegexArray(keywords):
    regexPartsArray = []
    for word in keywords:
        wordWithoutSpecialChars = re.sub("[^a-z0-9-]", ".?", word, re.IGNORECASE)
        regexPartsArray.append(wordWithoutSpecialChars)

    separatorPattern = "[-_\s]+"
    regexArray = [
        "^(" + "|".join(regexPartsArray) + ")",
        "(" + "|".join(regexPartsArray) + ")$",
        "(" + separatorPattern + "|".join(regexPartsArray) + separatorPattern + ")",
    ]
    return regexArray


class CliHandlers:

    def createNewNote(self, noteSuffix, graphicalEditor, encrypt):

        noteName = createNewNote(noteSuffix)
        Logger.info("Note have been created: " + noteName)

        editNote(noteName, graphicalEditor)

        if encrypt is True:
            encryptGpg(noteName)

    def editNote(self, noteIdentifier, graphicalEditor, encrypt):

        notePath = resolveNoteName(noteIdentifier, encrypt)
        if notePath is None:
            raise Exception("Unable to find note: " + noteIdentifier)

        if encrypt is True:
            decryptGpg(notePath)
            notePath = encryptedToClearNoteName(notePath)

        editNote(notePath, graphicalEditor)

        if encrypt is True:
            encryptGpg(notePath)

    def editTemplate(self, graphicalEditor):

        editNote(Configuration.TEMPLATE_PATH, graphicalEditor)

    def listNotes(self):

        notePaths = listNotePaths()
        if len(notePaths) < 1:
            raise Exception("No notes available in: " + Configuration.NOTE_REPO_PATH)

        for noteName in notePaths:
            displayNoteCompact(noteName)

    def displayNote(self, noteIdentifier):

        notePath = resolveNoteName(noteIdentifier)

        if notePath is None:
            raise Exception("Unable to found note: " + noteIdentifier)

        displayNote(notePath)

    def displayAll(self):

        Logger.info("Notes from directory: " + Configuration.NOTE_REPO_PATH)
        Logger.info()

        for path in listNotePaths():
            displayNote(path)

    def searchNote(self, keywords):

        if len(keywords) < 1:
            raise Exception("You must specify keywords.")

        Logger.info("Notes from directory: " + Configuration.NOTE_REPO_PATH)
        Logger.info()

        regexArray = buildSearchRegexArray(keywords)
        someWhereFound = False

        # TODO: refactor search
        for path in listNotePaths():
            for line in getLinesFromNote(path):
                noteMatch = False
                for regex in regexArray:
                    matchLine = re.search(regex, line, re.IGNORECASE)
                    if matchLine:
                        displayNote(path, Configuration.NUMBER_OF_LINE_ON_LIST, regex)
                        noteMatch = True
                        someWhereFound = True
                        break
                if noteMatch:
                    break

        if not someWhereFound:
            raise Exception("Nothing found: " + ", ".join(keywords))


def parseArguments():
    # parse arguments
    parser = argparse.ArgumentParser(description=Configuration.PGRM_DESC)

    parser.add_argument("-k", "--encrypt",
                        action="store_true",
                        help="encrypt with gpg (symetric) after edit")

    parser.add_argument("-n", "--newnote",
                        action="store_true",
                        help="create a new note")

    parser.add_argument("-e", "--editnote",
                        action="store_true",
                        help="edit exisiting note")

    parser.add_argument("-s", "--search",
                        action="store_true",
                        help="search in all notes")

    parser.add_argument("-t", "--edittemplate",
                        action="store_true",
                        help="edit template")

    parser.add_argument("-l", "--list",
                        action="store_true",
                        help="list all notes")

    parser.add_argument("-d", "--display",
                        action="store_true",
                        help="display a note")

    parser.add_argument("-a", "--displayall",
                        action="store_true",
                        help="display all notes")

    parser.add_argument("-g", "--graphicaleditor",
                        action="store_true",
                        help="use graphical editor")

    knownArgs, unknownArgs = parser.parse_known_args()

    cliHandlers = CliHandlers()

    if knownArgs.newnote:

        noteSuffix = unknownArgs[0] if len(unknownArgs) > 0 else None
        cliHandlers.createNewNote(noteSuffix, knownArgs.graphicaleditor, knownArgs.encrypt)

    elif knownArgs.editnote:

        if len(unknownArgs) != 1:
            raise Exception("You must specify a name, a partial name or a number.")

        noteIdentifier = unknownArgs[0]
        cliHandlers.editNote(noteIdentifier, knownArgs.graphicaleditor, knownArgs.encrypt)

    elif knownArgs.edittemplate:

        cliHandlers.editTemplate(knownArgs.graphicaleditor)

    elif knownArgs.list:

        cliHandlers.listNotes()

    elif knownArgs.display:

        if len(unknownArgs) != 1:
            raise Exception("You must specify a name, a partial name or a number.")

        noteIdentifier = unknownArgs[0]
        cliHandlers.displayNote(noteIdentifier)

    elif knownArgs.displayall:

        cliHandlers.displayAll()

    elif knownArgs.search:

        keywords = unknownArgs
        cliHandlers.searchNote(keywords)

    else:
        Exception("Bad command, please try --help")


if __name__ == "__main__":

    try:
        parseArguments()
    except Exception as e:
        Logger.error()
        Logger.error(str(e.args[0]))
        Logger.error()

        if Configuration.DEBUG:
            raise e

        exit(1)
