#!/usr/bin/env python3
# encoding: utf-8

import argparse
import datetime
import os
import re
import shutil
import subprocess
from typing import List


class Configuration:
    DEBUG = False

    NUMBER_OF_LINE_ON_LIST = 5
    GRAPHICAL_EDITOR = "xdg-open"
    CLI_EDITOR = "vim"

    NOTE_REPO_NAME = "repository"
    NOTE_REPO_PATH = os.path.join(os.path.dirname(os.path.realpath(__file__)), NOTE_REPO_NAME)

    NOTE_NAME_PREFIX = "note_"
    NOTE_EXTENSION = "md"
    ENCRYPTED_NOTE_EXTENSION = ".gpg"

    TEMPLATE_NAME = ".template.md"
    TEMPLATE_PATH = os.path.join(NOTE_REPO_PATH, TEMPLATE_NAME)

    PGRM_DESC = '''
Small utility to save notes.
Notes are saved in: ''' + NOTE_REPO_PATH


class Note:

    def __init__(self):
        self.id = -1
        self.path = ''
        self.title = ''
        self.content = []

    @staticmethod
    def getNoteFromPath(notePath: str, id: int):
        with open(notePath, "r") as file:
            fileLines = file.readlines()

            note = Note()
            note.id = id
            note.path = notePath
            note.title = fileLines[0][:-1]
            note.content = list(map(lambda line: line[:-1], fileLines[1:]))

            return note

    def getContentMatching(self, keywords) -> List[str]:
        regexArray = self.__buildSearchRegexArray(keywords)
        return list(filter(lambda line: self.__isLineMatching(line, regexArray), self.content))

    def hasTitleMatching(self, keywords) -> bool:
        regexArray = self.__buildSearchRegexArray(keywords)
        return self.__isLineMatching(self.title, regexArray)

    def display(self, lineMax=None, keywords=None):
        greenId = self.__getGreenId()
        blueTitle = self.__getBlueTitle()
        Logger.info(greenId + " " + blueTitle)
        Logger.print('Path: ' + self.path)
        Logger.print()

        if keywords:
            notesLines = self.getContentMatching(keywords)
            notesLines = self.__highligthMatch(notesLines, keywords)
        else:
            notesLines = self.content

        if lineMax is not None:
            notesLines = notesLines[:lineMax]

        if len(notesLines) > 0:
            for line in notesLines:
                print(line)
        else:
            Logger.warning("** Note is empty **")

        Logger.info("")

    def displayCompact(self):
        greenId = self.__getGreenId()
        blueTitle = self.__getBlueTitle()
        Logger.info(greenId + " " + blueTitle)

    def edit(self, useGraphicalEditor=False):
        """
        Edit a note, with graphical or non graphical editor
        """
        editor = Configuration.GRAPHICAL_EDITOR if useGraphicalEditor is True else Configuration.CLI_EDITOR
        editCommand = editor + " " + self.path
        subprocess.call(editCommand, shell=True)

    def commit(self, action: str = "Update"):

        if action == "Update" and self.isModified() is False:
            Logger.info('No modifications to commit !')
            return

        addCommand = "git add " + self.path
        self.__shellCommand(addCommand, Configuration.NOTE_REPO_PATH)

        commitMessage = action + " " + str(os.path.split(self.path)[-1:][0])
        commitCommand = "git commit -m '" + commitMessage + "' " + self.path
        self.__shellCommand(commitCommand, Configuration.NOTE_REPO_PATH)

    def isModified(self):
        completed = subprocess.run("git diff --exit-code --name-only " + self.path,
                                   shell=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
        return completed.returncode == 1

    def encryptGpg(self):
        encryptedNotePath = self.__clearToEncryptedNotePath()
        encryptNoteCommand = "gpg --yes --armor --output " \
                             + encryptedNotePath \
                             + " --symmetric " \
                             + self.path + " && sync"
        self.__shellCommand(encryptNoteCommand)

        shredCommand = "shred -u " + self.path + " && sync"
        self.__shellCommand(shredCommand)

        self.path = encryptedNotePath

    def decryptGpg(self):
        clearNotePath = self.__encryptedToClearNotePath()
        decryptCommand = "gpg --yes --decrypt --output " + clearNotePath + " " + self.path + " && sync"
        self.__shellCommand(decryptCommand)

        self.path = clearNotePath

    def isEncrypted(self) -> bool:
        return self.path.endswith(Configuration.ENCRYPTED_NOTE_EXTENSION)

    def __clearToEncryptedNotePath(self):
        return self.path + Configuration.ENCRYPTED_NOTE_EXTENSION

    def __encryptedToClearNotePath(self):
        return self.path[:-len(Configuration.ENCRYPTED_NOTE_EXTENSION)]

    def __getBlueTitle(self) -> str:
        return Colors.BLUE + self.title + Colors.ENDC

    def __getGreenId(self) -> str:
        return Colors.GREEN + "@" + str(self.id).ljust(3) + Colors.ENDC

    def __isLineMatching(self, line: str, regexArray) -> bool:
        for regex in regexArray:
            if re.search(regex, line, re.IGNORECASE) is not None:
                return True
        return False

    def __highligthMatch(self, lines: List[str], keywords: List[str]) -> List[str]:
        regexArray = self.__buildSearchRegexArray(keywords)
        result = []
        for line in lines:
            for regex in regexArray:
                match = re.search(regex, line, re.IGNORECASE)
                if match is not None:
                    line = re.sub(regex, Colors.YELLOW + match.group(1) + Colors.ENDC, line, re.IGNORECASE)
            result.append(line)
        return result

    def __buildSearchRegexArray(self, keywords) -> List:
        regexPartsArray = []
        for word in keywords:
            wordWithoutSpecialChars = re.sub("[^a-z0-9-]", ".?", word, re.IGNORECASE)
            regexPartsArray.append(wordWithoutSpecialChars)

        separatorPattern = "[-_\s]+"
        regexArray = [
            "^(" + "|".join(regexPartsArray) + ")",
            "(" + "|".join(regexPartsArray) + ")$",
            "(" + separatorPattern + "|".join(regexPartsArray) + separatorPattern + ")",
        ]
        return regexArray

    def __shellCommand(self, command, pwd=None) -> None:
        completedProcess = subprocess.run(command, shell=True,
                                          stdout=subprocess.PIPE,
                                          stderr=subprocess.PIPE,
                                          cwd=pwd)
        if completedProcess.returncode is not 0:
            raise Exception('Error: ' + str(completedProcess.stderr))


class Colors:
    PURPLE = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    UNDERLINE = '\033[4m'


class Logger:

    @staticmethod
    def header(line=""):
        Logger.printColor(line, Colors.UNDERLINE)

    @staticmethod
    def success(line=""):
        Logger.printColor(line, Colors.GREEN)

    @staticmethod
    def info(line=""):
        Logger.printColor(line)

    @staticmethod
    def warning(line=""):
        Logger.printColor(line, Colors.YELLOW)

    @staticmethod
    def error(line=""):
        Logger.printColor(line, Colors.RED)

    @staticmethod
    def printColor(line="", color=Colors.ENDC):
        Logger.print(color + str(line) + Colors.ENDC)

    @staticmethod
    def print(line = ""):
        print(line)


class NotesContainer:

    def __init__(self):
        self.notePaths = []

    def getAllNotes(self):
        paths = self.getNotePaths()
        return list(map(lambda path: self.getNoteFromPath(path), paths))

    def resolveNotePath(self, query: str):
        """
        Try to resolve a note name regardless it is a note name, partial name or number.
        Return None if nothing is found
        """
        # arg is a full path
        if os.path.isfile(query) is True:
            return query

        # arg is a note number
        if re.search("^[0-9]+$", query):
            notes = self.getNotePaths()
            if int(query) < len(notes):
                return notes[int(query)]

        # arg is a relative path or a partial name
        if len(query.split(os.sep)) < 2:

            # relative path: return absolute path
            notePath = os.path.join(Configuration.NOTE_REPO_PATH, query)
            if os.path.isfile(notePath):
                return notePath

            # partial name: search
            for path in self.getNotePaths():
                if re.search(query, path, re.IGNORECASE) is not None:
                    return path

        raise Exception("Unable to find note: " + query)

    def getNotePaths(self):
        """
        Return an ordered list of note paths
        """
        if len(self.notePaths) < 1:

            self.notePaths = []
            dirList = os.listdir(Configuration.NOTE_REPO_PATH)

            for fname in dirList:
                if fname == "." or fname == ".." or fname == Configuration.TEMPLATE_NAME \
                       or fname.startswith('.'):
                    continue
                fullPath = os.path.join(Configuration.NOTE_REPO_PATH, fname)
                self.notePaths.append(fullPath)

            self.notePaths.sort()

            if len(self.notePaths) < 1:
                raise Exception("No notes available in: " + Configuration.NOTE_REPO_PATH)

        return self.notePaths

    def createNewNote(self, newNoteName: str) -> Note:
        newNotePath = os.path.join(Configuration.NOTE_REPO_PATH, newNoteName)
        shutil.copy(Configuration.TEMPLATE_PATH, newNotePath)

        noteId = self.getNewNoteId()
        note = Note.getNoteFromPath(newNotePath, noteId)

        return note

    def getNewNoteId(self):
        return len(self.getNotePaths())

    def getNoteFromPath(self, notePath):
        noteId = self.getNoteIdFromPath(notePath)
        return Note.getNoteFromPath(notePath, noteId)

    def getNoteIdFromPath(self, notePath) -> int:
        return self.notePaths.index(notePath)

    def getNewNoteName(self, suffix) -> str:
        today = datetime.datetime.now()
        newNoteName = Configuration.NOTE_NAME_PREFIX + today.strftime('%Y-%m-%d_%H-%M-%S')
        if suffix is not None:
            newNoteName += "_" + suffix
        newNoteName += "." + Configuration.NOTE_EXTENSION
        return newNoteName

    def checkNoteRepository(self):
        """
        Check if repository and templates exist, or try to create them
        """
        if os.path.isdir(Configuration.NOTE_REPO_PATH) is False:
            os.makedirs(Configuration.NOTE_REPO_PATH)
            Logger.info("Note repository was created here: " + Configuration.NOTE_REPO_PATH)

        # create note template
        if os.path.isfile(Configuration.TEMPLATE_PATH) is False:
            with open(Configuration.TEMPLATE_PATH, 'a') as file:
                file.close()


class CliHandlers:

    def __init__(self):
        self.notes = NotesContainer()

    def createNewNote(self, noteSuffix, graphicalEditor, encrypt):

        if encrypt is True and graphicalEditor:
            raise Exception('Encryption is available only with cli editor')

        noteName = self.notes.getNewNoteName(noteSuffix)
        Logger.info("Note have been created: " + noteName)

        note: Note = self.notes.createNewNote(noteName)
        note.edit(graphicalEditor)

        if encrypt is True:
            note.encryptGpg()

        note.commit(action="Create")

    def editNote(self, noteIdentifier, graphicalEditor, encrypt):

        if encrypt is True and graphicalEditor:
            raise Exception('Encryption is available only with cli editor')

        notePath = self.notes.resolveNotePath(noteIdentifier)
        note = self.notes.getNoteFromPath(notePath)

        if encrypt is True:
            note.decryptGpg()

        note.edit(graphicalEditor)

        if encrypt is True:
            note.encryptGpg()

        if graphicalEditor is True:
            Logger.warning('Notes are not committed when graphical editor is used')
        else:
            note.commit()

    def editTemplate(self, graphicalEditor):
        Note.getNoteFromPath(Configuration.TEMPLATE_PATH, -1).edit(graphicalEditor)

    def listNotes(self, listFilter: List[str] = []):
        hasFilter = len(listFilter) > 0
        notePaths = self.notes.getNotePaths()
        for index, notePath in enumerate(notePaths):
            note = Note.getNoteFromPath(notePath, index)
            if hasFilter and note.hasTitleMatching(listFilter):
                note.displayCompact()
            elif hasFilter is not True:
                note.displayCompact()

    def displayNote(self, noteIdentifier):
        notePath = self.notes.resolveNotePath(noteIdentifier)
        note = self.notes.getNoteFromPath(notePath)

        Logger.print()
        note.display()

    def displayAll(self):

        Logger.info("Notes from directory: " + Configuration.NOTE_REPO_PATH)
        Logger.info()

        notePaths = self.notes.getNotePaths()

        for index, notePath in enumerate(notePaths):
            note = Note.getNoteFromPath(notePath, index)
            note.display()

    def searchNote(self, keywords: List[str]):

        Logger.info("Notes from directory: " + Configuration.NOTE_REPO_PATH)
        Logger.info()

        someWhereFound = False
        for note in self.notes.getAllNotes():

            if note.isEncrypted():
                continue

            matchingContent = note.getContentMatching(keywords)
            if len(matchingContent) > 0:
                note.display(lineMax=Configuration.NUMBER_OF_LINE_ON_LIST, keywords=keywords)
                someWhereFound = True

        if not someWhereFound:
            raise Exception("Nothing found: " + ", ".join(keywords))

    def removeNote(self, noteId: str):

        notePath = self.notes.resolveNotePath(noteId)
        note = self.notes.getNoteFromPath(notePath)

        os.remove(notePath)
        note.commit('Delete')

        Logger.print('Note deleted: ' + notePath)



def parseArguments():
    # parse arguments
    parser = argparse.ArgumentParser(description=Configuration.PGRM_DESC)

    parser.add_argument("-k", "--encrypt",
                        action="store_true",
                        help="encrypt with gpg (symmetric) after edit")

    parser.add_argument("-n", "--newnote",
                        action="store_true",
                        help="create a new note")

    parser.add_argument("-e", "--editnote",
                        action="store_true",
                        help="edit exisiting note")

    parser.add_argument("-s", "--search",
                        action="store_true",
                        help="search in all notes")

    parser.add_argument("-t", "--edittemplate",
                        action="store_true",
                        help="edit template")

    parser.add_argument("-l", "--list",
                        action="store_true",
                        help="list all notes")

    parser.add_argument("-d", "--display",
                        action="store_true",
                        help="display a note")

    parser.add_argument("-a", "--displayall",
                        action="store_true",
                        help="display all notes")

    parser.add_argument("-g", "--graphicaleditor",
                        action="store_true",
                        help="use graphical editor")

    parser.add_argument("-r", "--remove",
                        action="store_true",
                        help="remove note")

    knownArgs, unknownArgs = parser.parse_known_args()

    cliHandlers = CliHandlers()

    if knownArgs.newnote:
        noteSuffix = unknownArgs[0] if len(unknownArgs) > 0 else None
        cliHandlers.createNewNote(noteSuffix, knownArgs.graphicaleditor, knownArgs.encrypt)

    elif knownArgs.editnote:
        if len(unknownArgs) != 1:
            raise Exception("You must specify a name, a partial name or a number.")

        noteIdentifier = unknownArgs[0]
        cliHandlers.editNote(noteIdentifier, knownArgs.graphicaleditor, knownArgs.encrypt)

    elif knownArgs.edittemplate:
        cliHandlers.editTemplate(knownArgs.graphicaleditor)

    elif knownArgs.list:
        listFilter = []
        if len(unknownArgs) > 0:
            listFilter = unknownArgs

        cliHandlers.listNotes(listFilter)

    elif knownArgs.display:
        if len(unknownArgs) != 1:
            raise Exception("You must specify a name, a partial name or a number.")

        noteIdentifier = unknownArgs[0]
        cliHandlers.displayNote(noteIdentifier)

    elif knownArgs.displayall:
        cliHandlers.displayAll()

    elif knownArgs.search:
        keywords = unknownArgs

        if len(keywords) < 1:
            raise Exception("You must specify keywords.")

        cliHandlers.searchNote(keywords)

    elif knownArgs.remove:
        noteId = unknownArgs[0]
        if re.search("^[0-9]+$", noteId) is None:
            raise Exception('You must specify a numeric id')

        cliHandlers.removeNote(noteId)

    else:
        raise Exception("Bad command, please try --help")


if __name__ == "__main__":

    try:
        parseArguments()
    except Exception as e:
        Logger.error()
        Logger.error(str(e.args[0]))
        Logger.error()

        if Configuration.DEBUG:
            raise e

        exit(1)
