#!/usr/bin/env python3

#
# Usage:
#
# $ sudo npm i -g ts-node typescript
#
# Allow to execute commands in specified directory.
#
# Usage:
#
#  $ cd ../dir/
#  $ bcommand register "npm run compile-watch" "category"
#  $ bcommand run all
#  $ bcommand run category
#
#

import json
import os
import sys
import time
from subprocess import Popen

home = os.path.expanduser("~")
COMMAND_LIST_PATH = os.path.join(home, '.bcommand')


class TermStyle():
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    ENDC = '\033[0m'


class Utils():
    @staticmethod
    def log(message='', data=None, termStyle=TermStyle.OKGREEN):
        print(termStyle + str(message) + TermStyle.ENDC)
        if data:
            print(data)


class Command():
    def __init__(self, shellCommand, workingDir):
        self.shellCommand = shellCommand
        self.workingDir = workingDir
        self.popen = None

    def toList(self):
        return [self.shellCommand, self.workingDir]

    def execute(self):
        self.log('Starting command')
        self.popen = Popen(self.shellCommand, shell=True, cwd=self.workingDir)

    def log(self, message):
        Utils.log('[' + self.workingDir + ', ' + self.shellCommand + ']: ' + message)

    def isAlive(self):
        return self.popen is not None and self.popen.poll() is None

    def kill(self):
        if self.isAlive():
            self.log('Command was alive, killing it')
            self.popen.kill()
        else:
            self.log('Command was not alive')

    @staticmethod
    def fromList(list):
        return Command(list[0], list[1])


Utils.log('Bcommand !')
Utils.log()


class ActionHandlers:
    def __init__(self):
        self.commandList = []

    def showHelp(self):
        Utils.log('Register and execute commands')

    def registerCommand(self, shellCommand, workingDir):
        self.commandList.append(Command(shellCommand, workingDir))

    def displayCommands(self):
        Utils.log('Registered commands: ')
        for i, com in enumerate(self.commandList):
            self.displayCommand(i, com)

    def displayCommand(self, index, command):
        Utils.log('[' + str(index) + '] ' + command.workingDir + ': ' + command.shellCommand)

    def persistCommands(self):
        rawList = []
        for command in self.commandList:
            rawList.append(command.toList())

        with open(COMMAND_LIST_PATH, 'w') as outfile:
            json.dump(rawList, outfile)

    def loadCommands(self):
        try:
            with open(COMMAND_LIST_PATH, 'r') as infile:
                rawList = json.load(infile)
                self.commandList = []
                for item in rawList:
                    self.commandList.append(Command.fromList(item))

        except Exception as e:
            Utils.log('Preference file not found: ', e, TermStyle.WARNING)
            self.commandList = []

    def cleanAllCommands(self):
        self.commandList = []

    def cleanCommand(self, commandId):
        self.commandList.pop(commandId)

    def exit(self, code=0):
        keepAlive = self.isCommandsAlive()
        while keepAlive:
            try:
                keepAlive = self.isCommandsAlive()
                self.printCommandsOutput()
                time.sleep(0.2)
            except (KeyboardInterrupt, SystemExit):
                Utils.log('Stopping commands ...')
                for com in self.commandList:
                    com.kill()
        exit(code)

    def execute(self, commandIds):
        for comId in commandIds:
            self.commandList[int(comId)].execute()

    def isCommandsAlive(self):
        if len(self.commandList) == 0:
            return False
        for com in self.commandList:
            if com.isAlive():
                return True
        return False

    def printCommandsOutput(self):
        pass


class ArgParser:
    def __init__(self):
        self.actions = ActionHandlers()
        self.actions.loadCommands()

    def processArgs(self, args):
        cleanArgs = self.cleanArgs(args)

        # print(cleanArgs)

        if '-h' in cleanArgs:
            self.actions.showHelp()
            self.actions.exit()

        if len(cleanArgs) < 2:
            self.actions.displayCommands()
            self.actions.exit(1)

        if cleanArgs[1] == 'register':
            shellCommand = cleanArgs[2]
            workingDir = os.getcwd()
            self.actions.registerCommand(shellCommand, workingDir)
            self.actions.persistCommands()
            Utils.log('Command registered.')
            self.actions.displayCommands()
            self.actions.exit()

        if cleanArgs[1] == 'clean' and len(cleanArgs) == 2:
            self.actions.cleanAllCommands()
            self.actions.persistCommands()
            Utils.log('All commands cleaned !')
            self.actions.exit()

        if cleanArgs[1] == 'clean' and len(cleanArgs) > 2:
            commandIds = cleanArgs[2]
            self.actions.cleanCommand(int(commandIds))
            self.actions.persistCommands()
            Utils.log('Command cleaned.')
            self.actions.displayCommands()
            self.actions.exit()

        if cleanArgs[1] == 'run' and len(cleanArgs) > 2:
            commandIds = cleanArgs[2:]
            Utils.log('Starting commands: ' + str(commandIds))
            self.actions.execute(commandIds)
            self.actions.exit()

    def cleanArgs(self, arguments):
        res = []
        for arg in arguments:
            res.append(arg.strip())
        return res


if __name__ == '__main__':
    argParser = ArgParser()
    argParser.processArgs(sys.argv)
