#!/usr/bin/env python3

#
# Usage:
#
# $ sudo npm i -g ts-node typescript
#
# Allow to execute commands in specified directory.
#
# Usage:
#
#  $ cd ../dir/
#  $ bcommand register "npm run compile-watch"
#  $ bcommand run
#  $ bcommand run 0 1
#  $ bcommand run category -> Coming soon !
#
#

import fcntl
import json
import os
import random
import sys
import time
from subprocess import *

home = os.path.expanduser("~")
COMMAND_LIST_PATH = os.path.join(home, '.bcommand')
ENCODING = 'utf-8'


class TermStyle():
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    CYAN = "\033[1;36m"
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    RESET = '\033[0m'


class Utils():
    @staticmethod
    def log(message='', data=None, termStyle=TermStyle.GREEN):
        print(Utils.colorize(message, termStyle=termStyle))
        if data:
            print(data)

    @staticmethod
    def colorize(message, termStyle=TermStyle.GREEN):
        return termStyle + str(message) + TermStyle.RESET

    @staticmethod
    def normalize(str, maxLen):
        if len(str) > maxLen:
            start = len(str) - maxLen + 3
            str = '...' + str[start:len(str)]
        if len(str) < maxLen:
            blank = ''
            while len(blank) + len(str) < maxLen:
                blank += ' '
            str = blank + str
        return str


class Command():
    def __init__(self, id, shellCommand, workingDir, category=None):
        self.id = id
        self.color = random.choice([TermStyle.BLUE, TermStyle.CYAN, TermStyle.YELLOW, TermStyle.GREEN])
        self.shellCommand = shellCommand
        self.workingDir = workingDir
        self.category = category
        self.process = None

    @staticmethod
    def fromList(list):
        return Command(list[0], list[1], list[2], list[3])

    def toList(self):
        return [self.id, self.shellCommand, self.workingDir, self.category]

    def execute(self):
        self.log('Starting command: ' + self.shellCommand)
        self.process = Popen(self.shellCommand, shell=True, cwd=self.workingDir, stderr=PIPE, stdout=PIPE)

    def log(self, message, termStyle=TermStyle.GREEN):
        if len(message) > 0:
            prefix = self.getLogPrefix()
            Utils.log(Utils.colorize('[ ' + prefix + ' ]: ', termStyle=termStyle) + message)

    def getLogPrefix(self):
        nWorkingDir = Utils.normalize(self.workingDir, 20)
        nShellCommand = Utils.normalize(self.shellCommand, 20)
        prefix = nWorkingDir + ': ' + nShellCommand
        return prefix

    def isAlive(self):
        return self.process is not None and self.process.poll() is None

    def kill(self):
        if self.isAlive():
            self.log('Command was alive, killing it: ' + self.shellCommand)
            self.process.kill()
        else:
            self.log('Command was not alive: ' + self.shellCommand)

    def printOutput(self):

        if self.process is None:
            return

        stdout = self.process.stdout
        if stdout is not None:
            out = self.nonBlockReadOutput(stdout)
            if out is not None:
                for line in out.decode(ENCODING).rstrip().splitlines():
                    self.log(line, termStyle=self.color)

        stderr = self.process.stderr
        if stderr is not None:
            out = self.nonBlockReadOutput(stderr)
            if out is not None:
                for line in out.decode(ENCODING).rstrip().splitlines():
                    self.log(line, termStyle=TermStyle.RED)

    def nonBlockReadOutput(self, output):
        fd = output.fileno()
        fl = fcntl.fcntl(fd, fcntl.F_GETFL)
        fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)
        try:
            return output.read()
        except:
            return None


class ActionHandlers:
    def __init__(self):
        self.commandList = []

    def showHelp(self):
        Utils.log('Register and execute commands')
        Utils.log('')
        Utils.log('Examples: ')
        Utils.log('\t$ cd project && bcomm register "npm run compile-watch"')
        Utils.log('\t$ cd project && bcomm register "npm run gulp-watch"')
        Utils.log('\t$ bcomm show')
        Utils.log('\t$ bcomm run')
        Utils.log('\t$ bcomm run 0')
        Utils.log('\t$ bcomm run 0 1')
        Utils.log('\t$ bcomm remove 1')
        Utils.log('\t$ bcomm clean-all')

    def registerCommand(self, shellCommand, workingDir, category):
        id = len(self.commandList)
        command = Command(id, shellCommand, workingDir, category)
        self.commandList.append(command)

    def displayCommands(self):
        if len(self.commandList) > 0:
            Utils.log('Registered commands: ')
            Utils.log()
            for i, com in enumerate(self.commandList):
                self.displayCommand(i, com)
        else:
            Utils.log('No command registered yet !')

    def displayCommand(self, index, command):
        categoryStr = 'default'
        if command.category is not None:
            categoryStr = command.category
        prefix = Utils.colorize('[' + str(index) + '] [ ' + categoryStr + ' ] ' + command.workingDir + ': ')
        Utils.log(prefix + command.shellCommand)

    def persistCommands(self):
        rawList = []
        for command in self.commandList:
            rawList.append(command.toList())

        with open(COMMAND_LIST_PATH, 'w') as outfile:
            json.dump(rawList, outfile, indent=4, sort_keys=True)

    def loadCommands(self):
        try:
            with open(COMMAND_LIST_PATH, 'r') as infile:
                rawList = json.load(infile)
                self.commandList = []
                for item in rawList:
                    self.commandList.append(Command.fromList(item))

        except Exception as e:
            Utils.log('Command list file not found: ', e, TermStyle.YELLOW)
            self.commandList = []

    def cleanAllCommands(self):
        self.commandList = []

    def cleanCommand(self, commandId):
        self.commandList.pop(commandId)

    def exit(self, code=0):
        keepAlive = self.isCommandsAlive()
        while keepAlive:
            try:
                keepAlive = self.isCommandsAlive()
                self.printCommandsOutput()
                time.sleep(0.2)
            except (KeyboardInterrupt, SystemExit):
                Utils.log()
                Utils.log()
                Utils.log('Stopping commands ...', termStyle=TermStyle.YELLOW)
                Utils.log()
                for com in self.commandList:
                    com.kill()
        exit(code)

    def printCommandsOutput(self):
        for com in self.commandList:
            com.printOutput()

    def execute(self, commandIds):
        for comId in commandIds:
            self.commandList[int(comId)].execute()

    def executeAll(self):
        for com in self.commandList:
            com.execute()

    def isCommandsAlive(self):
        if len(self.commandList) == 0:
            return False
        for com in self.commandList:
            if com.isAlive():
                return True
        return False


class ArgParser:
    def __init__(self):
        self.actions = ActionHandlers()
        self.actions.loadCommands()

    def processArgs(self, args):
        cleanArgs = self.cleanArgs(args)

        # print(cleanArgs)

        if len(cleanArgs) < 2:
            self.actions.showHelp()
            self.actions.exit(1)

        if cleanArgs[1] == 'show':
            self.actions.showHelp()
            self.actions.exit()

        if cleanArgs[1] == 'show':
            self.actions.displayCommands()
            self.actions.exit()

        if cleanArgs[1] == 'register':

            if len(cleanArgs) < 3:
                Utils.log('You must specify a command to register', termStyle=TermStyle.RED)
                self.actions.exit(1)
            shellCommand = cleanArgs[2]

            category = None
            if len(cleanArgs) > 3:
                category = cleanArgs[3]

            workingDir = os.getcwd()
            self.actions.registerCommand(shellCommand, workingDir, category)
            self.actions.persistCommands()

            Utils.log('Command registered.')
            Utils.log()

            self.actions.displayCommands()
            self.actions.exit()

        if cleanArgs[1] == 'clean-all':
            self.actions.cleanAllCommands()
            self.actions.persistCommands()

            Utils.log('All commands cleaned !')
            Utils.log()

            self.actions.exit()

        if cleanArgs[1] == 'remove' and len(cleanArgs) > 2:
            commandIds = cleanArgs[2:]
            for cmdId in commandIds:
                self.actions.cleanCommand(int(cmdId))
            self.actions.persistCommands()

            Utils.log('Commands cleaned: ' + str(commandIds))
            Utils.log()

            self.actions.displayCommands()
            self.actions.exit()

        if cleanArgs[1] == 'run' and len(cleanArgs) == 2:

            Utils.log()
            Utils.log('Starting all commands')
            Utils.log()

            if len(self.actions.commandList) > 0:
                self.actions.executeAll()
                self.actions.exit()
            else:
                Utils.log('No command to run', termStyle=TermStyle.YELLOW)
                self.actions.exit(1)

        if cleanArgs[1] == 'run' and len(cleanArgs) > 2:
            commandIds = cleanArgs[2:]

            Utils.log('Starting commands: ' + str(commandIds))
            Utils.log()

            self.actions.execute(commandIds)
            self.actions.exit()

        Utils.log('Bad command.', termStyle=TermStyle.RED)
        Utils.log()
        self.actions.showHelp()
        self.actions.exit(1)

    def cleanArgs(self, arguments):
        res = []
        for arg in arguments:
            res.append(arg.strip())
        return res


if __name__ == '__main__':
    Utils.log('Bookmarked commands !')
    Utils.log()

    argParser = ArgParser()
    argParser.processArgs(sys.argv)
